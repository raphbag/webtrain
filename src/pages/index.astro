---
import FilterPanel from '../components/FilterPanel.astro';
import Layout from '../layouts/Layout.astro';
---

<script>
	import '../scripts/markerClusterer.js';
</script>

<Layout title="Webtrain - Visualisation des lignes de transport">
	<div id="map" class="h-screen w-full"></div>
	
	<!-- Contrôles principaux -->
	<div id="controls" class="absolute top-5 left-1/2 -translate-x-1/2 z-20 bg-white px-4 py-3 rounded-lg shadow-md text-center">
		<button id="loadLinesBtn" class="bg-blue-600 text-white border-0 px-5 py-2.5 rounded cursor-pointer text-sm font-medium hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed">Charger les lignes de transport</button>
		<div id="status" class="mt-2.5 text-xs text-gray-600 font-medium"></div>
	</div>

	<FilterPanel />
</Layout>

<script is:inline>
	(g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await (a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t[0].toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})({
		key: "AIzaSyD4YVEYyDMupCWQG_uzbgE81KrvMRuLYLY",
		v: "weekly",
		internalUsageAttributionIds: "gmp_mcp_codeassist_v0.1_github"
	});

	// URLs des datasets IDFM
	// Réseau ferré (métro, RER, tramway, train) - tracés précis
	const FERRE_URL = 'https://data.iledefrance-mobilites.fr/api/explore/v2.1/catalog/datasets/traces-du-reseau-ferre-idf/exports/geojson?limit=-1';
	// Référentiel des lignes (pour les images)
	const REFERENTIEL_URL = 'https://data.iledefrance-mobilites.fr/api/explore/v2.1/catalog/datasets/referentiel-des-lignes/records?limit=-1';
	// Arrêts des lignes - format GeoJSON
	const ARRETS_URL = 'https://data.iledefrance-mobilites.fr/api/explore/v2.1/catalog/datasets/arrets-lignes/exports/geojson?limit=-1';
	
	let map;
	let allLines = {}; // Stocker toutes les lignes par route_id
	let categories = {}; // Catégories de transport
	let lineImages = {}; // Cache des images de lignes
	let allStops = {}; // Stocker tous les arrêts par ligne
	const MIN_ZOOM_FOR_STOPS = 15; // Zoom minimum pour afficher les arrêts (très zoomé)

	async function initMap() {
		// Coordonnées de Paris
		const position = { lat: 48.852969, lng: 2.349903 };

		// Charger les bibliothèques Maps et Marker
		const { Map } = await google.maps.importLibrary("maps");
		const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");

		// Créer la carte
		map = new Map(document.getElementById("map"), {
			zoom: 11,
			center: position,
			mapId: "MAP_IDF"
		});
		
		// Stocker les classes pour utilisation ultérieure
		window.markerLibrary = { AdvancedMarkerElement, PinElement };

		// Initialiser le stockage global pour le filtre
		window.filterPanelData = {
			allLines: {},
			categories: {},
			map: map,
			allStops: {}
		};
		
		// Afficher les arrêts uniquement si très zoomé et dans la zone visible
		map.addListener('bounds_changed', () => {
			updateStopsVisibility();
		});

		// Activer le bouton de chargement des lignes
		document.getElementById('loadLinesBtn').addEventListener('click', loadTransitLines);
	}

	async function loadTransitLines() {
		const btn = document.getElementById('loadLinesBtn');
		const status = document.getElementById('status');
		
		btn.disabled = true;
		status.textContent = 'Chargement des référentiels...';

		try {
			// Récupérer d'abord le référentiel des lignes pour les images
			status.textContent = 'Chargement du référentiel des lignes...';
			const referentielResponse = await fetch(REFERENTIEL_URL);
			if (referentielResponse.ok) {
				const referentielData = await referentielResponse.json();
				if (referentielData.results) {
					referentielData.results.forEach(line => {
						if (line.picto && line.picto.url) {
							const lineId = line.id_line;
							lineImages[lineId] = line.picto.url;
							lineImages[`IDFM:${lineId}`] = line.picto.url;
						}
						// Essayer aussi picto_final s'il existe
						if (line.picto_final) {
							const lineId = line.id_line;
							// Si c'est un chemin relatif, construire l'URL complète
							const imageUrl = line.picto_final.startsWith('http') 
								? line.picto_final 
								: `https://data.iledefrance-mobilites.fr${line.picto_final}`;
							lineImages[lineId] = imageUrl;
							lineImages[`IDFM:${lineId}`] = imageUrl;
						}
					});
					console.log('Images des lignes chargées:', Object.keys(lineImages).length);
				}
			}
			
			// Réinitialiser les données
			allLines = {};
			categories = {};
			allStops = {};
			let drawn = 0;
			const bounds = new google.maps.LatLngBounds();
			
			// Charger le réseau ferré
			status.textContent = 'Chargement du réseau ferré d\'Île-de-France...';
			const ferreResponse = await fetch(FERRE_URL);
			if (!ferreResponse.ok) {
				throw new Error(`Erreur HTTP: ${ferreResponse.status}`);
			}
			
			const ferreData = await ferreResponse.json();
			console.log('Données réseau ferré reçues:', ferreData);
			
			if (ferreData.features && ferreData.features.length > 0) {
				status.textContent = `${ferreData.features.length} lignes ferrées trouvées. Tracé en cours...`;
				
				for (const feature of ferreData.features) {
					if (feature.geometry && feature.properties) {
						const routeName = feature.properties.res_com || feature.properties.indice_lig || 'Ligne';
						const routeColor = feature.properties.colourweb_hexa ? 
						                  `#${feature.properties.colourweb_hexa}` : 
						                  '#FF0000';
						const mode = feature.properties.mode || '';
						const reseau = feature.properties.reseau || '';
						
						// Déterminer la catégorie selon le mode et le réseau
						let category = 'Autre';
						let weight = 4;
						
						// Ordre de priorité pour la classification
						if (feature.properties.metro === 1 || mode === 'METRO') {
							category = 'Métro';
							weight = 5;
						} else if (feature.properties.tramway === 1 || mode === 'TRAMWAY') {
							category = 'Tram';
							weight = 4;
						} else if (mode === 'TER') {
							// TER a priorité sur tout (même si le réseau contient RER dans le nom)
							category = 'TER';
							weight = 4;
						} else if (feature.properties.rer === 1 || (reseau.startsWith('RER') && mode !== 'TER')) {
							// RER seulement si ce n'est pas un TER
							category = 'RER';
							weight = 5;
						} else if (mode === 'TRAIN' || feature.properties.train === 1) {
							// Les trains H, J, K, L, N, P, R, U, V sont des Transilien
							if (routeName.match(/TRAIN [HJKLNPRUV]$/)) {
								category = 'Transilien';
							} else {
								// Autres trains (probablement des TER régionaux)
								category = 'TER';
							}
							weight = 4;
						}
						
						// Utiliser routeName comme clé unique pour regrouper les segments
						const uniqueKey = `${category}_${routeName}`;
						
						// Récupérer l'image de la ligne
						const routeId = feature.properties.idrefligc || feature.properties.idrefliga;
						const lineId = routeId?.replace('IDFM:', '') || '';
						
						// Essayer plusieurs stratégies pour trouver l'image
						let lineImageUrl = lineImages[routeId] || lineImages[lineId];
						
						// Si picto_final existe et semble être une URL relative, construire l'URL complète
						if (!lineImageUrl && feature.properties.picto_final) {
							const pictoPath = feature.properties.picto_final;
							lineImageUrl = pictoPath.startsWith('http') 
								? pictoPath 
								: `https://data.iledefrance-mobilites.fr${pictoPath}`;
						}
						
						const polylines = createPolylinesFromGeometry(
							feature.geometry, 
							routeColor, 
							routeName, 
							weight,
							bounds,
							feature.properties
						);
						
						// Ne pas ajouter si pas de polylines
						if (polylines.length === 0) continue;
						
						// Si la ligne existe déjà, ajouter les polylines
						if (window.filterPanelData.allLines[uniqueKey]) {
							window.filterPanelData.allLines[uniqueKey].polylines.push(...polylines);
							// Mettre à jour l'originalRouteId si pas encore défini
							if (!window.filterPanelData.allLines[uniqueKey].originalRouteId && routeId) {
								window.filterPanelData.allLines[uniqueKey].originalRouteId = routeId;
							}
						} else {
							// Créer une nouvelle entrée de ligne
							window.filterPanelData.allLines[uniqueKey] = {
								routeId: uniqueKey,
								routeName,
								routeColor,
								routeType: category,
								properties: feature.properties,
								polylines,
								visible: true,
								imageUrl: lineImageUrl,
								originalRouteId: routeId // Garder l'ID original pour matcher avec les arrêts
							};
							
							// Catégoriser (seulement la première fois)
							if (!window.filterPanelData.categories[category]) {
								window.filterPanelData.categories[category] = [];
							}
							window.filterPanelData.categories[category].push(uniqueKey);
							drawn++;
						}
						
						if (drawn % 20 === 0) {
							status.textContent = `Réseau ferré: ${drawn} lignes...`;
							await new Promise(resolve => setTimeout(resolve, 10));
						}
					}
				}
				
				status.textContent = `✓ ${drawn} lignes ferrées affichées !`;
				console.log(`Réseau ferré chargé: ${drawn} lignes`);
				console.log('Catégories:', Object.keys(window.filterPanelData.categories));
				
				// Charger les arrêts
				status.textContent = 'Chargement des arrêts...';
				await loadStops(bounds);
				
				// Ajuster la vue pour afficher toutes les lignes
				map.fitBounds(bounds);
				
				// Créer l'interface de filtres via le composant
				if (window.buildFilterUI) {
					window.buildFilterUI();
				}
				if (window.showFilterPanel) {
					window.showFilterPanel();
				}
				
				status.textContent = `✓ ${drawn} lignes ferrées et arrêts affichés !`;
			} else {
				status.textContent = 'Aucune ligne trouvée dans les données';
			}
		} catch (error) {
			console.error('Erreur:', error);
			status.textContent = `Erreur: ${error.message}`;
		} finally {
			btn.disabled = false;
		}
	}

	async function loadStops(bounds) {
		try {
			const response = await fetch(ARRETS_URL);
			if (!response.ok) {
				throw new Error(`Erreur HTTP arrêts: ${response.status}`);
			}
			
			const data = await response.json();
			console.log('Données arrêts GeoJSON reçues:', data);
			
			if (data.features && data.features.length > 0) {
				console.log('Nombre d\'arrêts:', data.features.length);
				let stopsLoaded = 0;
				let stopsSkipped = 0;
				let stopsDuplicated = 0;
				const status = document.getElementById('status');
				
				// Créer un mapping des lignes par leur ID original
				const linesByOriginalId = {};
				Object.values(window.filterPanelData.allLines).forEach(line => {
					if (line.originalRouteId) {
						// Ajouter avec l'ID tel quel
						linesByOriginalId[line.originalRouteId] = line;
						
						// Ajouter aussi avec/sans le préfixe IDFM: pour maximiser les chances de match
						if (line.originalRouteId.startsWith('IDFM:')) {
							const withoutPrefix = line.originalRouteId.replace('IDFM:', '');
							linesByOriginalId[withoutPrefix] = line;
						} else {
							linesByOriginalId[`IDFM:${line.originalRouteId}`] = line;
						}
					}
				});
				
				console.log('Lignes disponibles:', Object.keys(linesByOriginalId).length);
				console.log('IDs de lignes:', Object.keys(linesByOriginalId).slice(0, 10));
				
				// Examiner la structure du premier arrêt
				if (data.features.length > 0) {
					console.log('Structure du premier arrêt:', data.features[0]);
					console.log('ID de la ligne:', data.features[0].properties.id);
					console.log('Cette ligne existe?', linesByOriginalId[data.features[0].properties.id]);
				}
				
				// Tracker les arrêts déjà ajoutés par nom et ligne pour éviter les doublons
				const seenStops = new Map();
				
				for (const feature of data.features) {
					// GeoJSON avec geometry.type = "Point" et geometry.coordinates = [lng, lat]
					if (feature.geometry && feature.geometry.type === 'Point' && feature.properties) {
						const properties = feature.properties;
						const [lng, lat] = feature.geometry.coordinates;
						
						// 'id' correspond à la ligne (ex: IDFM:C01371)
						// Essayer avec et sans le préfixe IDFM:
						let routeId = properties.id;
						let line = linesByOriginalId[routeId];
						
						// Si pas trouvé, essayer sans le préfixe IDFM:
						if (!line && routeId && routeId.startsWith('IDFM:')) {
							const routeIdWithoutPrefix = routeId.replace('IDFM:', '');
							line = linesByOriginalId[routeIdWithoutPrefix];
						}
						
						// Si toujours pas trouvé, essayer avec le préfixe IDFM:
						if (!line && routeId && !routeId.startsWith('IDFM:')) {
							line = linesByOriginalId[`IDFM:${routeId}`];
						}
						
						if (!line) {
							stopsSkipped++;
							if (stopsSkipped < 5) {
								console.log('Arrêt ignoré - ligne non trouvée:', routeId, properties.stop_name);
							}
							continue; // Ignorer les arrêts de lignes non chargées
						}
						
						// Créer une clé unique pour cet arrêt basée sur son nom et sa ligne
						const stopName = properties.stop_name || 'Arrêt inconnu';
						const stopKey = `${line.routeId}|${stopName}`;
						
						// Vérifier si cet arrêt avec ce nom a déjà été ajouté pour cette ligne
						if (seenStops.has(stopKey)) {
							stopsDuplicated++;
							continue;
						}
						seenStops.set(stopKey, true);
						
						// Créer le marker
						const marker = createStopMarker(
							{ lat: parseFloat(lat), lng: parseFloat(lng) },
							properties,
							line
						);
						
						if (stopsLoaded < 5) {
							console.log('Marker créé:', marker, 'pour arrêt:', properties.stop_name, 'ligne:', line.routeName);
						}
						
						// Stocker le marker dans allStops par ligne
						if (!window.filterPanelData.allStops[line.routeId]) {
							window.filterPanelData.allStops[line.routeId] = [];
						}
						window.filterPanelData.allStops[line.routeId].push(marker);
						
						// Ajouter à la ligne
						if (!line.stops) {
							line.stops = [];
						}
						line.stops.push(marker);
						
						stopsLoaded++;
						
						if (stopsLoaded % 100 === 0) {
							status.textContent = `Arrêts: ${stopsLoaded}...`;
							await new Promise(resolve => setTimeout(resolve, 5));
						}
					}
				}
				
				console.log(`${stopsLoaded} arrêts chargés, ${stopsSkipped} ignorés, ${stopsDuplicated} doublons supprimés`);
				
				// Afficher initialement selon le zoom
				updateStopsVisibility();
			}
		} catch (error) {
			console.error('Erreur chargement arrêts:', error);
		}
	}
	
	function updateStopsVisibility() {
		if (!map) return;
		
		const currentZoom = map.getZoom();
		const shouldShowStops = currentZoom >= MIN_ZOOM_FOR_STOPS;
		
		if (!shouldShowStops) {
			// Masquer tous les markers
			Object.values(window.filterPanelData.allStops || {}).forEach(stops => {
				stops.forEach(marker => {
					marker.map = null;
				});
			});
			return;
		}
		
		// Obtenir les limites visibles de la carte
		const bounds = map.getBounds();
		if (!bounds) return;
		
		// Afficher uniquement les markers visibles des lignes actives
		Object.entries(window.filterPanelData.allStops || {}).forEach(([routeId, stops]) => {
			const line = window.filterPanelData.allLines[routeId];
			const lineVisible = line && line.visible;
			
			stops.forEach(marker => {
				// Afficher uniquement si la ligne est visible ET le marker est dans les limites
				if (lineVisible && bounds.contains(marker.position)) {
					marker.map = map;
				} else {
					marker.map = null;
				}
			});
		});
	}

	function createStopMarker(position, properties, line) {
		if (!window.markerLibrary) {
			console.error('markerLibrary not available yet');
			return null;
		}
		
		const { PinElement, AdvancedMarkerElement } = window.markerLibrary;
		
		// Créer un élément pin personnalisé avec la couleur de la ligne
		const pinElement = new PinElement({
			background: line.routeColor,
			borderColor: '#FFFFFF',
			glyphColor: '#FFFFFF',
			scale: 0.7
		});
		
		// Ne pas ajouter à la carte initialement
		const marker = new AdvancedMarkerElement({
			position,
			map: null,
			title: properties.stop_name || 'Arrêt',
			content: pinElement.element,
			gmpClickable: true
		});

		// Info-bulle au clic
		marker.addListener('click', () => {
			const infoWindow = new google.maps.InfoWindow({
				content: `
					<div style="padding: 10px; min-width: 150px;">
						<h4 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600;">${properties.stop_name || 'Arrêt'}</h4>
						<p style="margin: 4px 0; font-size: 12px; color: #666;">Ligne: ${line.routeName}</p>
						${properties.stop_id ? `<p style="margin: 4px 0; font-size: 11px; color: #999;">ID: ${properties.stop_id}</p>` : ''}
					</div>
				`,
				position
			});
			infoWindow.open(map);
		});

		return marker;
	}

	function createPolylinesFromGeometry(geometry, color, name, weight, bounds, properties) {
		const polylines = [];
		
		if (!geometry || !geometry.coordinates) return polylines;

		// Parser les coordonnées selon le type de géométrie
		if (geometry.type === 'LineString') {
			const path = geometry.coordinates.map(coord => {
				const latLng = new google.maps.LatLng(coord[1], coord[0]);
				bounds.extend(latLng);
				return latLng;
			});
			polylines.push(createPolyline(path, color, name, weight, properties));
		} else if (geometry.type === 'MultiLineString') {
			geometry.coordinates.forEach(lineString => {
				const path = lineString.map(coord => {
					const latLng = new google.maps.LatLng(coord[1], coord[0]);
					bounds.extend(latLng);
					return latLng;
				});
				polylines.push(createPolyline(path, color, name, weight, properties));
			});
		}
		
		return polylines;
	}

	function createPolyline(path, color, name, weight, properties) {
		// Créer une polyline avec geodesic: false pour afficher exactement les coordonnées brutes
		const polyline = new google.maps.Polyline({
			path: path,
			geodesic: false,
			strokeColor: color,
			strokeOpacity: 0.75,
			strokeWeight: weight,
			map: map,
			clickable: true
		});

		// Ajouter info-bulle au clic
		polyline.addListener('click', (event) => {
			const routeType = getRouteTypeName(properties.route_type);
			const infoWindow = new google.maps.InfoWindow({
				content: `
					<div style="padding: 10px; min-width: 200px;">
						<h3 style="margin: 0 0 8px 0; font-size: 16px; font-weight: 600;">${name}</h3>
						${routeType ? `<p style="margin: 4px 0; font-size: 13px; color: #666;">Type: ${routeType}</p>` : ''}
						${properties.route_id ? `<p style="margin: 4px 0; font-size: 12px; color: #999;">ID: ${properties.route_id}</p>` : ''}
						${properties.operatorname ? `<p style="margin: 4px 0; font-size: 12px; color: #999;">Opérateur: ${properties.operatorname}</p>` : ''}
					</div>
				`,
				position: event.latLng
			});
			infoWindow.open(map);
		});

		return polyline;
	}

	// Fonction pour obtenir le nom du type de transport
	function getRouteTypeName(routeType) {
		const types = {
			'0': 'Tramway',
			'1': 'Métro',
			'2': 'Train',
			'3': 'Bus',
			'4': 'Ferry',
			'5': 'Téléphérique',
			'6': 'Téléphérique suspendu',
			'7': 'Funiculaire',
			'Bus': 'Bus',
			'Métro': 'Métro',
			'Train': 'Train',
			'Tramway': 'Tramway',
			'RER': 'RER',
			'VAL': 'VAL'
		};
		return types[routeType] || routeType || 'Transport';
	}

	// Exposer la fonction updateStopsVisibility globalement pour le FilterPanel
	window.updateStopsVisibility = updateStopsVisibility;

	initMap();
</script>
