---
import FilterPanel from '../components/FilterPanel.astro';
import Layout from '../layouts/Layout.astro';

const googleMapsApiKey = import.meta.env.PUBLIC_GOOGLE_MAPS_API_KEY;
---

<script>
	import '../scripts/markerClusterer';
	import { fetchStopSchedules, generateSchedulesElement, fetchLineDisruptions } from '../scripts/stopMonitoring';
	
	// Exposer globalement pour utilisation dans le code inline
	// @ts-ignore
	if (typeof window !== 'undefined') {
		// @ts-ignore
		window.fetchStopSchedules = fetchStopSchedules;
		// @ts-ignore
		window.generateSchedulesElement = generateSchedulesElement;
		// @ts-ignore
		window.fetchLineDisruptions = fetchLineDisruptions;
	}
</script>

<Layout title="Webtrain - Visualisation des lignes de transport">
	<div id="map" class="h-screen w-full z-0"></div>

	<FilterPanel />
</Layout>

<script is:inline define:vars={{ googleMapsApiKey }}>
	(g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await (a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t[0].toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})  ({
		key: googleMapsApiKey,
		v: "weekly"
	});

	// URLs des endpoints serveur
	const FERRE_URL = '/lignes.json';
	const GARES_URL = '/gares.json';
	
	// Configuration
	const REFRESH_INTERVAL_MS = 10000; // Intervalle d'actualisation en millisecondes (10 secondes)
	const MIN_ZOOM_FOR_STOPS = 15; // Zoom minimum pour afficher les arrêts (15 = très zoomé)
	
	let map;
	let allLines = {}; // Stocker toutes les lignes par route_id
	let categories = {}; // Catégories de transport
	let lineImages = {}; // Cache des images de lignes
	let allStops = {}; // Stocker tous les arrêts par ligne
	let currentInfoWindow = null; // InfoWindow actuellement ouverte
	let currentRefreshInterval = null; // Intervalle d'actualisation actuel
	let markerPositionMap = new Map(); // Map pour suivre les positions et décaler les markers superposés

	async function initMap() {
		// Coordonnées de Paris
		const position = { lat: 48.852969, lng: 2.349903 };

		// Charger les bibliothèques Maps et Marker
		const { Map } = await google.maps.importLibrary("maps");
		const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");
		const {ColorScheme} = await google.maps.importLibrary("core");
		

		// Créer la carte en 3D
		map = new Map(document.getElementById("map"), {
			zoom: 17,
			center: position,
			mapId: "768ca61f157a15a0673bb1ed",
			mapTypeId: 'terrain',
			renderingType: 'VECTOR',
			disableDefaultUI: true,
			zoomControl: true,
			gestureHandling: 'greedy',
			streetViewControl: true,
			fullscreenControl: true,
			mapTypeControl: true,
			tiltInteractionEnabled: true,
			colorScheme: ColorScheme.DARK,
			mapTypeControlOptions: {
				position: google.maps.ControlPosition.TOP_RIGHT,
				mapTypeIds: ['terrain', 'satellite']
			},
		});
		
		// Stocker les classes pour utilisation ultérieure
		window.markerLibrary = { AdvancedMarkerElement, PinElement };

		// Initialiser le stockage global pour le filtre
		window.filterPanelData = {
			allLines: {},
			categories: {},
			map: map,
			allStops: {}
		};
		
		// Afficher les arrêts uniquement si très zoomé et dans la zone visible
		map.addListener('bounds_changed', () => {
			updateStopsVisibility();
		});

		// Charger automatiquement les lignes de transport
		loadTransitLines();
	}

	async function loadTransitLines() {
		console.log('🚀 Chargement automatique des lignes de transport...');
		
		try {
			// Réinitialiser les données
			allLines = {};
			categories = {};
			allStops = {};
			let drawn = 0;
			const bounds = new google.maps.LatLngBounds();
			
			// Charger le réseau ferré
			console.log('📡 Chargement du réseau ferré d\'Île-de-France...');
			const ferreResponse = await fetch(FERRE_URL);
			if (!ferreResponse.ok) {
				throw new Error(`Erreur HTTP: ${ferreResponse.status}`);
			}
			
			const ferreData = await ferreResponse.json();
			
			if (ferreData.features && ferreData.features.length > 0) {
				console.log(`📍 ${ferreData.features.length} segments de lignes ferrées à traiter`);
				
				for (const feature of ferreData.features) {
					if (feature.geometry && feature.properties) {
						const routeName = feature.properties.res_com || feature.properties.indice_lig || 'Ligne';
						const routeColor = feature.properties.colourweb_hexa ? 
						                  `#${feature.properties.colourweb_hexa}` : 
						                  '#FF0000';
						const mode = feature.properties.mode || '';
						const reseau = feature.properties.reseau || '';
						
						// Déterminer la catégorie selon le mode et le réseau
						let category = 'Autre';
						let weight = 4;
						
						// Ordre de priorité pour la classification
						if (feature.properties.metro === 1 || mode === 'METRO') {
							category = 'Métro';
							weight = 5;
						} else if (feature.properties.tramway === 1 || mode === 'TRAMWAY') {
							category = 'Tram';
							weight = 4;
						} else if (mode === 'TER') {
							// TER a priorité sur tout (même si le réseau contient RER dans le nom)
							category = 'TER';
							weight = 4;
						} else if (feature.properties.rer === 1 || (reseau.startsWith('RER') && mode !== 'TER')) {
							// RER seulement si ce n'est pas un TER
							category = 'RER';
							weight = 5;
						} else if (mode === 'TRAIN' || feature.properties.train === 1) {
							// Les trains H, J, K, L, N, P, R, U, V sont des Transilien
							if (routeName.match(/TRAIN [HJKLNPRUV]$/)) {
								category = 'Transilien';
							} else {
								// Autres trains (probablement des TER régionaux)
								category = 'TER';
							}
							weight = 4;
						}
						
						// Utiliser routeName comme clé unique pour regrouper les segments
						const uniqueKey = `${category}_${routeName}`;
						
						// Récupérer l'image de la ligne
						const routeId = feature.properties.idrefligc || feature.properties.idrefliga;
						const lineId = routeId?.replace('IDFM:', '') || '';
						
						// Essayer plusieurs stratégies pour trouver l'image
						let lineImageUrl = lineImages[routeId] || lineImages[lineId];
						
						// Si picto_final existe et semble être une URL relative, construire l'URL complète
						if (!lineImageUrl && feature.properties.picto_final) {
							const pictoPath = feature.properties.picto_final;
							lineImageUrl = pictoPath.startsWith('http') 
								? pictoPath 
								: `https://data.iledefrance-mobilites.fr${pictoPath}`;
						}
						
						const polylines = createPolylinesFromGeometry(
							feature.geometry, 
							routeColor, 
							routeName, 
							weight,
							bounds,
							feature.properties
						);
						
						// Ne pas ajouter si pas de polylines
						if (polylines.length === 0) continue;
						
						// Si la ligne existe déjà, ajouter les polylines
						if (window.filterPanelData.allLines[uniqueKey]) {
							window.filterPanelData.allLines[uniqueKey].polylines.push(...polylines);
							// Mettre à jour l'originalRouteId si pas encore défini
							if (!window.filterPanelData.allLines[uniqueKey].originalRouteId && routeId) {
								window.filterPanelData.allLines[uniqueKey].originalRouteId = routeId;
							}
						} else {
							// Créer une nouvelle entrée de ligne
							window.filterPanelData.allLines[uniqueKey] = {
								routeId: uniqueKey,
								routeName,
								routeColor,
								routeType: category,
								properties: feature.properties,
								polylines,
								visible: true,
								imageUrl: lineImageUrl,
								originalRouteId: routeId // Garder l'ID original pour matcher avec les arrêts
							};
							
							// Catégoriser (seulement la première fois)
							if (!window.filterPanelData.categories[category]) {
								window.filterPanelData.categories[category] = [];
							}
							window.filterPanelData.categories[category].push(uniqueKey);
							drawn++;
						}
						
						if (drawn % 20 === 0) {
							console.log(`Réseau ferré: ${drawn} lignes...`);
							await new Promise(resolve => setTimeout(resolve, 10));
						}
					}
				}
				
				console.log(`✅ ${drawn} lignes ferrées chargées:`, Object.keys(window.filterPanelData.categories).map(cat => `${cat} (${window.filterPanelData.categories[cat].length})`).join(', '));
				
				// Charger les gares
				console.log('📡 Chargement des gares...');
				await loadStops(bounds);
				
				// Ajuster la vue pour afficher toutes les lignes
				map.fitBounds(bounds);
				
				// Créer l'interface de filtres via le composant
				if (window.buildFilterUI) {
					window.buildFilterUI();
				}
				if (window.showFilterPanel) {
					window.showFilterPanel();
				}
				
				console.log(`✅ ${drawn} lignes ferrées et arrêts affichés !`);
			} else {
				console.warn('Aucune ligne trouvée dans les données');
			}
		} catch (error) {
			console.error('Erreur:', error);
		}
	}

	async function loadStops(bounds) {
		try {
			const response = await fetch(GARES_URL);
			if (!response.ok) {
				throw new Error(`Erreur HTTP gares: ${response.status}`);
			}
			
			const data = await response.json();
			
			if (data.features && data.features.length > 0) {
				console.log(`🚉 ${data.features.length} gares à traiter`);
				let stopsLoaded = 0;
				let stopsSkipped = 0;
				
				// Créer un mapping des lignes par leur ID original
				const linesByOriginalId = {};
				Object.values(window.filterPanelData.allLines).forEach(line => {
					if (line.originalRouteId) {
						// Ajouter avec l'ID tel quel
						linesByOriginalId[line.originalRouteId] = line;
						
						// Ajouter aussi avec/sans le préfixe IDFM: pour maximiser les chances de match
						if (line.originalRouteId.startsWith('IDFM:')) {
							const withoutPrefix = line.originalRouteId.replace('IDFM:', '');
							linesByOriginalId[withoutPrefix] = line;
						} else {
							linesByOriginalId[`IDFM:${line.originalRouteId}`] = line;
						}
					}
				});
				
				console.log(`🔗 ${Object.keys(window.filterPanelData.allLines).length} lignes disponibles pour matching (idrefligc des tracés ↔ idrefligc des gares)`);
				
				// Tracker les gares déjà ajoutées par nom et ligne
				const stopsByNameAndLine = new Map();
				
				// Parcourir toutes les gares
				for (const feature of data.features) {
					if (feature.geometry && feature.geometry.type === 'Point' && feature.properties) {
						const properties = feature.properties;
						const [lng, lat] = feature.geometry.coordinates;
						
						// Récupérer idrefligc comme LineRef
						const routeId = properties.idrefligc;
						if (!routeId) {
							stopsSkipped++;
							continue;
						}
						
						let line = linesByOriginalId[routeId];
						
						if (!line && routeId.startsWith('IDFM:')) {
							const routeIdWithoutPrefix = routeId.replace('IDFM:', '');
							line = linesByOriginalId[routeIdWithoutPrefix];
						}
						
						if (!line && !routeId.startsWith('IDFM:')) {
							line = linesByOriginalId[`IDFM:${routeId}`];
						}
						
						if (!line) {
							stopsSkipped++;
							continue;
						}
						
						// Stocker l'image de ligne si disponible
						if (properties.picto && properties.picto.url && !line.imageUrl) {
							line.imageUrl = properties.picto.url;
							lineImages[routeId] = properties.picto.url;
						}
						
						const stopName = properties.nom_gares || properties.nom_iv || 'Gare inconnue';
						const stopKey = `${line.routeId}|${stopName}`;
						
						// Utiliser id_ref_zda comme MonitoringRef avec le préfixe STIF:StopArea:SP:
						const monitoringRef = properties.id_ref_zda ? `STIF:StopArea:SP:${properties.id_ref_zda}:` : null;
						
						// Regrouper par gare
						if (!stopsByNameAndLine.has(stopKey)) {
							stopsByNameAndLine.set(stopKey, {
								line,
								stopName,
								monitoringRef,
								exploitant: properties.exploitant,
								lat,
								lng
							});
						}
					}
				}
				
				// Créer les markers
				for (const [stopKey, stopData] of stopsByNameAndLine) {
					const { line, stopName, monitoringRef, exploitant, lat, lng } = stopData;
					
					if (!monitoringRef) {
						stopsSkipped++;
						continue;
					}
					
					// Calculer la position ajustée pour éviter les superpositions
					const adjustedPosition = getAdjustedMarkerPosition(
						parseFloat(lat), 
						parseFloat(lng), 
						line.routeId
					);
					
					// Créer le marker
					const marker = createStopMarker(
						adjustedPosition,
						{ 
							stop_name: stopName, 
							monitoring_ref: monitoringRef,
							exploitant: exploitant,
							original_lat: lat, 
							original_lng: lng 
						},
						line
					);

					
					if (!window.filterPanelData.allStops[line.routeId]) {
						window.filterPanelData.allStops[line.routeId] = [];
					}
					window.filterPanelData.allStops[line.routeId].push(marker);
					
					if (!line.stops) {
						line.stops = [];
					}
					line.stops.push(marker);
					
					stopsLoaded++;
					
					if (stopsLoaded % 100 === 0) {
						console.log(`Gares: ${stopsLoaded}...`);
						await new Promise(resolve => setTimeout(resolve, 5));
					}
				}
				
				console.log(`✅ ${stopsLoaded} gares chargées (${stopsSkipped} ignorées - lignes non trouvées ou sans idrefligc)`);
				
				// Afficher initialement selon le zoom
				updateStopsVisibility();
			}
		} catch (error) {
			console.error('Erreur chargement gares:', error);
		}
	}
	
	function updateStopsVisibility() {
		if (!map) return;
		
		const currentZoom = map.getZoom();
		const shouldShowStops = currentZoom >= MIN_ZOOM_FOR_STOPS;
		
		if (!shouldShowStops) {
			// Masquer tous les markers
			Object.values(window.filterPanelData.allStops || {}).forEach(stops => {
				stops.forEach(marker => {
					marker.map = null;
				});
			});
			return;
		}
		
		// Obtenir les limites visibles de la carte
		const bounds = map.getBounds();
		if (!bounds) return;
		
		// Afficher uniquement les markers visibles des lignes actives
		Object.entries(window.filterPanelData.allStops || {}).forEach(([routeId, stops]) => {
			const line = window.filterPanelData.allLines[routeId];
			const lineVisible = line && line.visible;
			
			stops.forEach(marker => {
				// Afficher uniquement si la ligne est visible ET le marker est dans les limites
				if (lineVisible && bounds.contains(marker.position)) {
					marker.map = map;
				} else {
					marker.map = null;
				}
			});
		});
	}

	// Fonction pour calculer une position ajustée afin d'éviter les superpositions
	function getAdjustedMarkerPosition(lat, lng, routeId) {
		const posKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
		
		if (!markerPositionMap.has(posKey)) {
			markerPositionMap.set(posKey, []);
		}
		
		const markersAtPosition = markerPositionMap.get(posKey);
		const offsetIndex = markersAtPosition.length;
		
		// Stocker l'info pour ce marker
		markersAtPosition.push(routeId);
		
		// Si c'est le premier marker à cette position, pas de décalage
		if (offsetIndex === 0) {
			return { lat, lng };
		}
		
		// Calculer un décalage en cercle autour de la position originale
		// Distance en degrés (très petite pour rester proche)
		const offsetDistance = 0.0001; // ~11 mètres
		const angle = (offsetIndex * (2 * Math.PI / 8)); // Répartir en cercle (8 positions max)
		
		const adjustedLat = lat + (offsetDistance * Math.cos(angle));
		const adjustedLng = lng + (offsetDistance * Math.sin(angle));
		
		return { lat: adjustedLat, lng: adjustedLng };
	}

	function createStopMarker(position, properties, line) {
		if (!window.markerLibrary) {
			console.error('markerLibrary not available yet');
			return null;
		}
		
		const { PinElement, AdvancedMarkerElement } = window.markerLibrary;
		
		// Créer un élément pin personnalisé avec la couleur de la ligne
		const pinElement = new PinElement({
			background: line.routeColor,
			borderColor: '#FFFFFF',
			glyphColor: '#FFFFFF',
			scale: 0.7
		});
		// Ne pas ajouter à la carte initialement
		const marker = new AdvancedMarkerElement({
			position,
			map: null,
			title: properties.stop_name || 'Arrêt',
			content: pinElement.element,
			gmpClickable: true
		});

		// Info-bulle au clic
		marker.addEventListener('gmp-click', async () => {
			// Fermer l'infoWindow précédente si elle existe
			if (currentInfoWindow) {
				currentInfoWindow.close();
			}
			
			// Arrêter l'actualisation précédente si elle existe
			if (currentRefreshInterval) {
				clearInterval(currentRefreshInterval);
				currentRefreshInterval = null;
			}
			
			// Nettoyer l'état des perturbations déroulées
			// Cela assure que toutes les perturbations sont fermées par défaut à l'ouverture
			Object.keys(sessionStorage).forEach(key => {
				if (key.startsWith('disruption-details-')) {
					sessionStorage.removeItem(key);
				}
			});
			
			const monitoringRef = properties.monitoring_ref;
			
			// Créer le conteneur avec Tailwind CSS
			const contentDiv = document.createElement('div');
			contentDiv.className = 'min-w-[200px] max-w-[400px]';
			
			// Header avec logo de ligne et titre
			const headerDiv = document.createElement('div');
			headerDiv.className = 'flex items-start gap-2 mb-2';
			
			// Logo de la ligne (si disponible)
			if (line.imageUrl) {
				const lineImage = document.createElement('img');
				lineImage.src = line.imageUrl;
				lineImage.alt = line.routeName;
				lineImage.className = 'w-8 h-8 object-contain flex-shrink-0 my-auto';
				lineImage.onerror = function() {
					this.style.display = 'none'; // Cacher si l'image ne charge pas
				};
				headerDiv.appendChild(lineImage);
			}
			
			// Conteneur pour titre et info ligne
			const titleContainer = document.createElement('div');
			titleContainer.className = 'flex-1';
			
			const title = document.createElement('h4');
			title.className = 'mb-1 text-sm font-semibold';
			title.textContent = properties.stop_name || 'Gare';
			titleContainer.appendChild(title);
			
			const lineInfo = document.createElement('p');
			lineInfo.className = 'my-1 text-xs text-gray-600';
			lineInfo.textContent = `Ligne: ${line.routeName}`;
			titleContainer.appendChild(lineInfo);
			
			headerDiv.appendChild(titleContainer);
			
			// Afficher l'exploitant
			if (properties.exploitant) {
				const exploitantInfo = document.createElement('p');
				exploitantInfo.className = 'my-1 text-[10px] text-gray-300';
				exploitantInfo.textContent = properties.exploitant;
				contentDiv.appendChild(exploitantInfo);
			}
			
			const schedulesContainer = document.createElement('div');
			schedulesContainer.id = 'schedules-content';
			schedulesContainer.className = 'mt-3';
			
			const loadingText = document.createElement('p');
			loadingText.className = 'text-[11px] text-gray-400';
			loadingText.textContent = 'Chargement des horaires...';
			schedulesContainer.appendChild(loadingText);
			
			contentDiv.appendChild(schedulesContainer);
			
			const infoWindow = new google.maps.InfoWindow({
				content: contentDiv,
				headerContent: headerDiv,
				position,
				zIndex: 10000
			});
			
			// Stocker l'infoWindow actuelle
			currentInfoWindow = infoWindow;
			infoWindow.open(map);
			
			// Fonction pour charger les horaires et perturbations
			const loadSchedules = async () => {
				if (monitoringRef && line.originalRouteId) {
					try {
						// Pour Métro et Tram : utiliser line_reports (pas de stop_point)
						// Pour RER, TER, Transilien : utiliser disruptions avec stop_point
						const useStopPoint = line.routeType !== 'Métro' && line.routeType !== 'Tram';
						const idRefZdA = useStopPoint ? monitoringRef.split(':')[3] : null;
						
						// Charger horaires et perturbations en parallèle
						const [allSchedules, disruptions] = await Promise.all([
							window.fetchStopSchedules(monitoringRef, line.originalRouteId, line.routeType),
							window.fetchLineDisruptions(line.originalRouteId, idRefZdA, line.routeType)
						]);
						
						const schedulesElement = window.generateSchedulesElement(allSchedules, line.routeType, disruptions);
						const container = document.getElementById('schedules-content');
						if (container) {
							container.innerHTML = '';
							container.appendChild(schedulesElement);
						}
					} catch (error) {
						console.error('Erreur chargement horaires:', error);
						const container = document.getElementById('schedules-content');
						if (container) {
							container.innerHTML = '';
							const errorText = document.createElement('p');
							errorText.className = 'text-[11px] text-gray-400';
							errorText.textContent = 'Erreur de chargement';
							container.appendChild(errorText);
						}
					}
				}
			};
			
			// Charger les horaires immédiatement
			loadSchedules();
			
			// Actualiser selon l'intervalle configuré
			currentRefreshInterval = setInterval(loadSchedules, REFRESH_INTERVAL_MS);
			
			// Arrêter l'actualisation quand l'info-bulle est fermée
			google.maps.event.addListener(infoWindow, 'closeclick', () => {
				if (currentRefreshInterval) {
					clearInterval(currentRefreshInterval);
					currentRefreshInterval = null;
				}
				currentInfoWindow = null;
				
				// Nettoyer l'état des perturbations déroulées pour cette station
				// Cela permet de remettre toutes les perturbations fermées par défaut à la prochaine ouverture
				Object.keys(sessionStorage).forEach(key => {
					if (key.startsWith('disruption-details-')) {
						sessionStorage.removeItem(key);
					}
				});
			});
		});

		return marker;
	}

	function createPolylinesFromGeometry(geometry, color, name, weight, bounds, properties) {
		const polylines = [];
		
		if (!geometry || !geometry.coordinates) return polylines;

		// Parser les coordonnées selon le type de géométrie
		if (geometry.type === 'LineString') {
			const path = geometry.coordinates.map(coord => {
				const latLng = new google.maps.LatLng(coord[1], coord[0]);
				bounds.extend(latLng);
				return latLng;
			});
			polylines.push(createPolyline(path, color, name, weight, properties));
		} else if (geometry.type === 'MultiLineString') {
			geometry.coordinates.forEach(lineString => {
				const path = lineString.map(coord => {
					const latLng = new google.maps.LatLng(coord[1], coord[0]);
					bounds.extend(latLng);
					return latLng;
				});
				polylines.push(createPolyline(path, color, name, weight, properties));
			});
		}
		
		return polylines;
	}

	function createPolyline(path, color, name, weight, properties) {
		// Créer une polyline avec geodesic: false pour afficher exactement les coordonnées brutes
		const polyline = new google.maps.Polyline({
			path: path,
			geodesic: false,
			strokeColor: color,
			strokeOpacity: 0.75,
			strokeWeight: weight,
			map: map,
			clickable: true
		});

		// Ajouter info-bulle au clic
		polyline.addListener('click', (event) => {
			// Fermer l'infoWindow précédente si elle existe
			if (currentInfoWindow) {
				currentInfoWindow.close();
			}
			
			// Arrêter l'actualisation précédente si elle existe
			if (currentRefreshInterval) {
				clearInterval(currentRefreshInterval);
				currentRefreshInterval = null;
			}
			
			const routeType = getRouteTypeName(properties.route_type);
			
			// Créer le conteneur avec Tailwind CSS
			const contentDiv = document.createElement('div');
			contentDiv.className = 'p-2.5 pt-0 min-w-[200px]';
			
			const title = document.createElement('h3');
			title.className = 'mb-2 text-base font-semibold';
			title.textContent = name;
			contentDiv.appendChild(title);
			
			if (routeType) {
				const typeP = document.createElement('p');
				typeP.className = 'my-1 text-[13px] text-gray-600';
				typeP.textContent = `Type: ${routeType}`;
				contentDiv.appendChild(typeP);
			}
			
			if (properties.route_id) {
				const idP = document.createElement('p');
				idP.className = 'my-1 text-xs text-gray-400';
				idP.textContent = `ID: ${properties.route_id}`;
				contentDiv.appendChild(idP);
			}
			
			if (properties.operatorname) {
				const operatorP = document.createElement('p');
				operatorP.className = 'my-1 text-xs text-gray-300';
				operatorP.textContent = `Opérateur: ${properties.operatorname}`;
				contentDiv.appendChild(operatorP);
			}
			
			const infoWindow = new google.maps.InfoWindow({
				content: contentDiv,
				position: event.latLng,
				zIndex: 10000
			});
			
			// Stocker l'infoWindow actuelle
			currentInfoWindow = infoWindow;
			infoWindow.open(map);
			
			// Nettoyer la référence quand fermée manuellement
			google.maps.event.addListener(infoWindow, 'closeclick', () => {
				currentInfoWindow = null;
			});
		});

		return polyline;
	}

	// Fonction pour obtenir le nom du type de transport
	function getRouteTypeName(routeType) {
		const types = {
			'0': 'Tramway',
			'1': 'Métro',
			'2': 'Train',
			'3': 'Bus',
			'4': 'Ferry',
			'5': 'Téléphérique',
			'6': 'Téléphérique suspendu',
			'7': 'Funiculaire',
			'Bus': 'Bus',
			'Métro': 'Métro',
			'Train': 'Train',
			'Tramway': 'Tramway',
			'RER': 'RER',
			'VAL': 'VAL'
		};
		return types[routeType] || routeType || 'Transport';
	}

	// Exposer la fonction updateStopsVisibility globalement pour le FilterPanel
	window.updateStopsVisibility = updateStopsVisibility;

	initMap();
</script>
