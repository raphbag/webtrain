---
import FilterPanel from '../components/FilterPanel.astro';
import Layout from '../layouts/Layout.astro';
---

<script>
	import '../scripts/markerClusterer.js';
	import { fetchStopSchedules, generateSchedulesElement } from '../scripts/stopMonitoring.js';
	
	// Exposer globalement pour utilisation dans le code inline
	// @ts-ignore: extending window with runtime-only properties
	window.fetchStopSchedules = fetchStopSchedules;
	// @ts-ignore: extending window with runtime-only properties
	window.generateSchedulesElement = generateSchedulesElement;
</script>

<Layout title="Webtrain - Visualisation des lignes de transport">
	<div id="map" class="h-screen w-full"></div>
	
	<!-- Contrôles principaux -->
	<div id="controls" class="absolute top-5 left-1/2 -translate-x-1/2 z-20 bg-white px-4 py-3 rounded-lg shadow-md text-center">
		<button id="loadLinesBtn" class="bg-blue-600 text-white border-0 px-5 py-2.5 rounded cursor-pointer text-sm font-medium hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed">Charger les lignes de transport</button>
		<div id="status" class="mt-2.5 text-xs text-gray-600 font-medium"></div>
	</div>

	<FilterPanel />
</Layout>

<script is:inline>
	(g=>{var h,a,k,p="The Google Maps JavaScript API",c="google",l="importLibrary",q="__ib__",m=document,b=window;b=b[c]||(b[c]={});var d=b.maps||(b.maps={}),r=new Set,e=new URLSearchParams,u=()=>h||(h=new Promise(async(f,n)=>{await (a=m.createElement("script"));e.set("libraries",[...r]+"");for(k in g)e.set(k.replace(/[A-Z]/g,t=>"_"+t[0].toLowerCase()),g[k]);e.set("callback",c+".maps."+q);a.src=`https://maps.${c}apis.com/maps/api/js?`+e;d[q]=f;a.onerror=()=>h=n(Error(p+" could not load."));a.nonce=m.querySelector("script[nonce]")?.nonce||"";m.head.append(a)}));d[l]?console.warn(p+" only loads once. Ignoring:",g):d[l]=(f,...n)=>r.add(f)&&u().then(()=>d[l](f,...n))})({
		key: "AIzaSyD4YVEYyDMupCWQG_uzbgE81KrvMRuLYLY",
		v: "weekly",
		internalUsageAttributionIds: "gmp_mcp_codeassist_v0.1_github"
	});

	// URLs des datasets IDFM
	// Réseau ferré (métro, RER, tramway, train) - tracés précis
	const FERRE_URL = 'https://data.iledefrance-mobilites.fr/api/explore/v2.1/catalog/datasets/traces-du-reseau-ferre-idf/exports/geojson?limit=-1';
	// Référentiel des lignes (pour les images)
	const REFERENTIEL_URL = 'https://data.iledefrance-mobilites.fr/api/explore/v2.1/catalog/datasets/referentiel-des-lignes/records?limit=-1';
	// Arrêts des lignes - format GeoJSON
	const ARRETS_URL = 'https://data.iledefrance-mobilites.fr/api/explore/v2.1/catalog/datasets/arrets-lignes/exports/geojson?where=mode != \'Bus\'';
	
	// Configuration
	const REFRESH_INTERVAL_MS = 10000; // Intervalle d'actualisation en millisecondes (10 secondes)
	const MIN_ZOOM_FOR_STOPS = 15; // Zoom minimum pour afficher les arrêts (15 = très zoomé)
	
	let map;
	let allLines = {}; // Stocker toutes les lignes par route_id
	let categories = {}; // Catégories de transport
	let lineImages = {}; // Cache des images de lignes
	let allStops = {}; // Stocker tous les arrêts par ligne
	let currentInfoWindow = null; // InfoWindow actuellement ouverte
	let currentRefreshInterval = null; // Intervalle d'actualisation actuel
	let markerPositionMap = new Map(); // Map pour suivre les positions et décaler les markers superposés

	async function initMap() {
		// Coordonnées de Paris
		const position = { lat: 48.852969, lng: 2.349903 };

		// Charger les bibliothèques Maps et Marker
		const { Map } = await google.maps.importLibrary("maps");
		const { AdvancedMarkerElement, PinElement } = await google.maps.importLibrary("marker");
		

		// Créer la carte
		map = new Map(document.getElementById("map"), {
			zoom: 11,
			center: position,
			mapId: "768ca61f157a15a0673bb1ed",
			disableDefaultUI: true,
			zoomControl: true,
			streetViewControl: true,
			fullscreenControl: true,
			mapTypeControl: true,
			mapTypeControlOptions: {
				position: google.maps.ControlPosition.TOP_RIGHT,
				mapTypeIds: ['roadmap', 'satellite']
			}
		});
		
		// Stocker les classes pour utilisation ultérieure
		window.markerLibrary = { AdvancedMarkerElement, PinElement };

		// Initialiser le stockage global pour le filtre
		window.filterPanelData = {
			allLines: {},
			categories: {},
			map: map,
			allStops: {}
		};
		
		// Afficher les arrêts uniquement si très zoomé et dans la zone visible
		map.addListener('bounds_changed', () => {
			updateStopsVisibility();
		});

		// Activer le bouton de chargement des lignes
		document.getElementById('loadLinesBtn').addEventListener('click', loadTransitLines);
	}

	async function loadTransitLines() {
		const btn = document.getElementById('loadLinesBtn');
		const status = document.getElementById('status');
		
		btn.disabled = true;
		status.textContent = 'Chargement des référentiels...';

		try {
			// Récupérer d'abord le référentiel des lignes pour les images
			status.textContent = 'Chargement du référentiel des lignes...';
			const referentielResponse = await fetch(REFERENTIEL_URL);
			if (referentielResponse.ok) {
				const referentielData = await referentielResponse.json();
				if (referentielData.results) {
					referentielData.results.forEach(line => {
						if (line.picto && line.picto.url) {
							const lineId = line.id_line;
							lineImages[lineId] = line.picto.url;
							lineImages[`IDFM:${lineId}`] = line.picto.url;
						}
						// Essayer aussi picto_final s'il existe
						if (line.picto_final) {
							const lineId = line.id_line;
							// Si c'est un chemin relatif, construire l'URL complète
							const imageUrl = line.picto_final.startsWith('http') 
								? line.picto_final 
								: `https://data.iledefrance-mobilites.fr${line.picto_final}`;
							lineImages[lineId] = imageUrl;
							lineImages[`IDFM:${lineId}`] = imageUrl;
						}
					});
					console.log('Images des lignes chargées:', Object.keys(lineImages).length);
				}
			}
			
			// Réinitialiser les données
			allLines = {};
			categories = {};
			allStops = {};
			let drawn = 0;
			const bounds = new google.maps.LatLngBounds();
			
			// Charger le réseau ferré
			status.textContent = 'Chargement du réseau ferré d\'Île-de-France...';
			const ferreResponse = await fetch(FERRE_URL);
			if (!ferreResponse.ok) {
				throw new Error(`Erreur HTTP: ${ferreResponse.status}`);
			}
			
			const ferreData = await ferreResponse.json();
			console.log('Données réseau ferré reçues:', ferreData);
			
			if (ferreData.features && ferreData.features.length > 0) {
				status.textContent = `${ferreData.features.length} lignes ferrées trouvées. Tracé en cours...`;
				
				for (const feature of ferreData.features) {
					if (feature.geometry && feature.properties) {
						const routeName = feature.properties.res_com || feature.properties.indice_lig || 'Ligne';
						const routeColor = feature.properties.colourweb_hexa ? 
						                  `#${feature.properties.colourweb_hexa}` : 
						                  '#FF0000';
						const mode = feature.properties.mode || '';
						const reseau = feature.properties.reseau || '';
						
						// Déterminer la catégorie selon le mode et le réseau
						let category = 'Autre';
						let weight = 4;
						
						// Ordre de priorité pour la classification
						if (feature.properties.metro === 1 || mode === 'METRO') {
							category = 'Métro';
							weight = 5;
						} else if (feature.properties.tramway === 1 || mode === 'TRAMWAY') {
							category = 'Tram';
							weight = 4;
						} else if (mode === 'TER') {
							// TER a priorité sur tout (même si le réseau contient RER dans le nom)
							category = 'TER';
							weight = 4;
						} else if (feature.properties.rer === 1 || (reseau.startsWith('RER') && mode !== 'TER')) {
							// RER seulement si ce n'est pas un TER
							category = 'RER';
							weight = 5;
						} else if (mode === 'TRAIN' || feature.properties.train === 1) {
							// Les trains H, J, K, L, N, P, R, U, V sont des Transilien
							if (routeName.match(/TRAIN [HJKLNPRUV]$/)) {
								category = 'Transilien';
							} else {
								// Autres trains (probablement des TER régionaux)
								category = 'TER';
							}
							weight = 4;
						}
						
						// Utiliser routeName comme clé unique pour regrouper les segments
						const uniqueKey = `${category}_${routeName}`;
						
						// Récupérer l'image de la ligne
						const routeId = feature.properties.idrefligc || feature.properties.idrefliga;
						const lineId = routeId?.replace('IDFM:', '') || '';
						
						// Essayer plusieurs stratégies pour trouver l'image
						let lineImageUrl = lineImages[routeId] || lineImages[lineId];
						
						// Si picto_final existe et semble être une URL relative, construire l'URL complète
						if (!lineImageUrl && feature.properties.picto_final) {
							const pictoPath = feature.properties.picto_final;
							lineImageUrl = pictoPath.startsWith('http') 
								? pictoPath 
								: `https://data.iledefrance-mobilites.fr${pictoPath}`;
						}
						
						const polylines = createPolylinesFromGeometry(
							feature.geometry, 
							routeColor, 
							routeName, 
							weight,
							bounds,
							feature.properties
						);
						
						// Ne pas ajouter si pas de polylines
						if (polylines.length === 0) continue;
						
						// Si la ligne existe déjà, ajouter les polylines
						if (window.filterPanelData.allLines[uniqueKey]) {
							window.filterPanelData.allLines[uniqueKey].polylines.push(...polylines);
							// Mettre à jour l'originalRouteId si pas encore défini
							if (!window.filterPanelData.allLines[uniqueKey].originalRouteId && routeId) {
								window.filterPanelData.allLines[uniqueKey].originalRouteId = routeId;
							}
						} else {
							// Créer une nouvelle entrée de ligne
							window.filterPanelData.allLines[uniqueKey] = {
								routeId: uniqueKey,
								routeName,
								routeColor,
								routeType: category,
								properties: feature.properties,
								polylines,
								visible: true,
								imageUrl: lineImageUrl,
								originalRouteId: routeId // Garder l'ID original pour matcher avec les arrêts
							};
							
							// Catégoriser (seulement la première fois)
							if (!window.filterPanelData.categories[category]) {
								window.filterPanelData.categories[category] = [];
							}
							window.filterPanelData.categories[category].push(uniqueKey);
							drawn++;
						}
						
						if (drawn % 20 === 0) {
							status.textContent = `Réseau ferré: ${drawn} lignes...`;
							await new Promise(resolve => setTimeout(resolve, 10));
						}
					}
				}
				
				status.textContent = `✓ ${drawn} lignes ferrées affichées !`;
				console.log(`Réseau ferré chargé: ${drawn} lignes`);
				console.log('Catégories:', Object.keys(window.filterPanelData.categories));
				
				// Charger les arrêts
				status.textContent = 'Chargement des arrêts...';
				await loadStops(bounds);
				
				// Ajuster la vue pour afficher toutes les lignes
				map.fitBounds(bounds);
				
				// Créer l'interface de filtres via le composant
				if (window.buildFilterUI) {
					window.buildFilterUI();
				}
				if (window.showFilterPanel) {
					window.showFilterPanel();
				}
				
				status.textContent = `✓ ${drawn} lignes ferrées et arrêts affichés !`;
				
				// Masquer le conteneur de contrôles après un court délai
				setTimeout(() => {
					const controls = document.getElementById('controls');
					if (controls) {
						controls.style.display = 'none';
					}
				}, 2000);
			} else {
				status.textContent = 'Aucune ligne trouvée dans les données';
			}
		} catch (error) {
			console.error('Erreur:', error);
			status.textContent = `Erreur: ${error.message}`;
		} finally {
			btn.disabled = false;
		}
	}

	async function loadStops(bounds) {
		try {
			const response = await fetch(ARRETS_URL);
			if (!response.ok) {
				throw new Error(`Erreur HTTP arrêts: ${response.status}`);
			}
			
			const data = await response.json();
			console.log('Données arrêts GeoJSON reçues:', data);
			
			if (data.features && data.features.length > 0) {
				console.log('Nombre d\'arrêts:', data.features.length);
				let stopsLoaded = 0;
				let stopsSkipped = 0;
				let stopsDuplicated = 0;
				const status = document.getElementById('status');
				
				// Créer un mapping des lignes par leur ID original
				const linesByOriginalId = {};
				Object.values(window.filterPanelData.allLines).forEach(line => {
					if (line.originalRouteId) {
						// Ajouter avec l'ID tel quel
						linesByOriginalId[line.originalRouteId] = line;
						
						// Ajouter aussi avec/sans le préfixe IDFM: pour maximiser les chances de match
						if (line.originalRouteId.startsWith('IDFM:')) {
							const withoutPrefix = line.originalRouteId.replace('IDFM:', '');
							linesByOriginalId[withoutPrefix] = line;
						} else {
							linesByOriginalId[`IDFM:${line.originalRouteId}`] = line;
						}
					}
				});
				
				console.log('Lignes disponibles:', Object.keys(linesByOriginalId).length);
				console.log('IDs de lignes:', Object.keys(linesByOriginalId).slice(0, 10));
				
				// Examiner la structure du premier arrêt
				if (data.features.length > 0) {
					console.log('Structure du premier arrêt:', data.features[0]);
					console.log('ID de la ligne:', data.features[0].properties.id);
					console.log('Cette ligne existe?', linesByOriginalId[data.features[0].properties.id]);
				}
				
				// Tracker les arrêts déjà ajoutés par nom et ligne pour regrouper les directions
				const stopsByNameAndLine = new Map();
				
				// Premier passage: regrouper tous les stop_id par nom de station
				for (const feature of data.features) {
					if (feature.geometry && feature.geometry.type === 'Point' && feature.properties) {
						const properties = feature.properties;
						const [lng, lat] = feature.geometry.coordinates;
						
						let routeId = properties.id;
						let line = linesByOriginalId[routeId];
						
						if (!line && routeId && routeId.startsWith('IDFM:')) {
							const routeIdWithoutPrefix = routeId.replace('IDFM:', '');
							line = linesByOriginalId[routeIdWithoutPrefix];
						}
						
						if (!line && routeId && !routeId.startsWith('IDFM:')) {
							line = linesByOriginalId[`IDFM:${routeId}`];
						}
						
						if (!line) {
							stopsSkipped++;
							continue;
						}
						
						const stopName = properties.stop_name || 'Arrêt inconnu';
						const stopKey = `${line.routeId}|${stopName}`;
						
						// Regrouper tous les stop_id pour cette station
						if (!stopsByNameAndLine.has(stopKey)) {
							stopsByNameAndLine.set(stopKey, {
								line,
								stopName,
								stopIds: [],
								lat,
								lng
							});
						}
						
						stopsByNameAndLine.get(stopKey).stopIds.push(properties.stop_id);
					}
				}
				
				// Deuxième passage: créer un seul marker par station avec tous les stop_id
				for (const [stopKey, stopData] of stopsByNameAndLine) {
					const { line, stopName, stopIds, lat, lng } = stopData;
					
					// Calculer la position ajustée pour éviter les superpositions
					const adjustedPosition = getAdjustedMarkerPosition(
						parseFloat(lat), 
						parseFloat(lng), 
						line.routeId
					);
					
					// Créer le marker avec tous les stop_id
					const marker = createStopMarker(
						adjustedPosition,
						{ stop_name: stopName, stop_ids: stopIds, original_lat: lat, original_lng: lng },
						line
					);
					
					if (stopsLoaded < 5) {
						console.log('Marker créé:', marker, 'pour arrêt:', stopName, 'ligne:', line.routeName, 'avec', stopIds.length, 'directions');
					}
					
					if (!window.filterPanelData.allStops[line.routeId]) {
						window.filterPanelData.allStops[line.routeId] = [];
					}
					window.filterPanelData.allStops[line.routeId].push(marker);
					
					if (!line.stops) {
						line.stops = [];
					}
					line.stops.push(marker);
					
					stopsLoaded++;
					
					if (stopsLoaded % 100 === 0) {
						status.textContent = `Arrêts: ${stopsLoaded}...`;
						await new Promise(resolve => setTimeout(resolve, 5));
					}
				}
				
				console.log(`${stopsLoaded} arrêts chargés, ${stopsSkipped} ignorés, ${stopsDuplicated} doublons supprimés`);
				
				// Afficher initialement selon le zoom
				updateStopsVisibility();
			}
		} catch (error) {
			console.error('Erreur chargement arrêts:', error);
		}
	}
	
	function updateStopsVisibility() {
		if (!map) return;
		
		const currentZoom = map.getZoom();
		const shouldShowStops = currentZoom >= MIN_ZOOM_FOR_STOPS;
		
		if (!shouldShowStops) {
			// Masquer tous les markers
			Object.values(window.filterPanelData.allStops || {}).forEach(stops => {
				stops.forEach(marker => {
					marker.map = null;
				});
			});
			return;
		}
		
		// Obtenir les limites visibles de la carte
		const bounds = map.getBounds();
		if (!bounds) return;
		
		// Afficher uniquement les markers visibles des lignes actives
		Object.entries(window.filterPanelData.allStops || {}).forEach(([routeId, stops]) => {
			const line = window.filterPanelData.allLines[routeId];
			const lineVisible = line && line.visible;
			
			stops.forEach(marker => {
				// Afficher uniquement si la ligne est visible ET le marker est dans les limites
				if (lineVisible && bounds.contains(marker.position)) {
					marker.map = map;
				} else {
					marker.map = null;
				}
			});
		});
	}

	// Fonction pour calculer une position ajustée afin d'éviter les superpositions
	function getAdjustedMarkerPosition(lat, lng, routeId) {
		const posKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
		
		if (!markerPositionMap.has(posKey)) {
			markerPositionMap.set(posKey, []);
		}
		
		const markersAtPosition = markerPositionMap.get(posKey);
		const offsetIndex = markersAtPosition.length;
		
		// Stocker l'info pour ce marker
		markersAtPosition.push(routeId);
		
		// Si c'est le premier marker à cette position, pas de décalage
		if (offsetIndex === 0) {
			return { lat, lng };
		}
		
		// Calculer un décalage en cercle autour de la position originale
		// Distance en degrés (très petite pour rester proche)
		const offsetDistance = 0.0001; // ~11 mètres
		const angle = (offsetIndex * (2 * Math.PI / 8)); // Répartir en cercle (8 positions max)
		
		const adjustedLat = lat + (offsetDistance * Math.cos(angle));
		const adjustedLng = lng + (offsetDistance * Math.sin(angle));
		
		return { lat: adjustedLat, lng: adjustedLng };
	}

	function createStopMarker(position, properties, line) {
		if (!window.markerLibrary) {
			console.error('markerLibrary not available yet');
			return null;
		}
		
		const { PinElement, AdvancedMarkerElement } = window.markerLibrary;
		
		// Créer un élément pin personnalisé avec la couleur de la ligne
		const pinElement = new PinElement({
			background: line.routeColor,
			borderColor: '#FFFFFF',
			glyphColor: '#FFFFFF',
			scale: 0.7
		});
		
		// Ne pas ajouter à la carte initialement
		const marker = new AdvancedMarkerElement({
			position,
			map: null,
			title: properties.stop_name || 'Arrêt',
			content: pinElement.element,
			gmpClickable: true
		});

		// Info-bulle au clic
		marker.addListener('click', async () => {
			// Fermer l'infoWindow précédente si elle existe
			if (currentInfoWindow) {
				currentInfoWindow.close();
			}
			
			// Arrêter l'actualisation précédente si elle existe
			if (currentRefreshInterval) {
				clearInterval(currentRefreshInterval);
				currentRefreshInterval = null;
			}
			
			const stopIds = properties.stop_ids || [properties.stop_id];
			const hasMultipleDirections = stopIds.length > 1;
			
			// Créer le conteneur avec Tailwind CSS
			const contentDiv = document.createElement('div');
			contentDiv.className = 'p-2.5 min-w-[250px] z-30';
			
			const title = document.createElement('h4');
			title.className = 'm-0 mb-2 text-sm font-semibold';
			title.textContent = properties.stop_name || 'Arrêt';
			contentDiv.appendChild(title);
			
			const lineInfo = document.createElement('p');
			lineInfo.className = 'my-1 text-xs text-gray-600';
			lineInfo.textContent = `Ligne: ${line.routeName}`;
			contentDiv.appendChild(lineInfo);
			
			if (hasMultipleDirections) {
				const directionInfo = document.createElement('p');
				directionInfo.className = 'my-1 text-[11px] text-gray-400';
				directionInfo.textContent = 'Toutes directions';
				contentDiv.appendChild(directionInfo);
			}
			
			const schedulesContainer = document.createElement('div');
			schedulesContainer.id = 'schedules-content';
			schedulesContainer.className = 'mt-3';
			
			const loadingText = document.createElement('p');
			loadingText.className = 'text-[11px] text-gray-400';
			loadingText.textContent = 'Chargement des horaires...';
			schedulesContainer.appendChild(loadingText);
			
			contentDiv.appendChild(schedulesContainer);
			
			const infoWindow = new google.maps.InfoWindow({
				content: contentDiv,
				position
			});
			
			// Stocker l'infoWindow actuelle
			currentInfoWindow = infoWindow;
			infoWindow.open(map);
			
			// Fonction pour charger les horaires de toutes les directions
			const loadSchedules = async () => {
				if (stopIds && stopIds.length > 0 && line.originalRouteId) {
					try {
						// Récupérer les horaires pour chaque direction
						const allSchedulesPromises = stopIds.map(stopId => 
							window.fetchStopSchedules(stopId, line.originalRouteId, line.routeType)
						);
						
						const allSchedulesResults = await Promise.all(allSchedulesPromises);
						
						// Fusionner tous les horaires
						const allSchedules = allSchedulesResults.flat();
						
						// Trier par ordre chronologique (utiliser expectedTime si disponible, sinon aimedTime)
						allSchedules.sort((a, b) => {
							const timeA = new Date(a.expectedTime || a.aimedTime);
							const timeB = new Date(b.expectedTime || b.aimedTime);
							return timeA - timeB;
						});
						
						const schedulesElement = window.generateSchedulesElement(allSchedules, line.routeType);
						const container = document.getElementById('schedules-content');
						if (container) {
							container.innerHTML = '';
							container.appendChild(schedulesElement);
						}
					} catch (error) {
						console.error('Erreur chargement horaires:', error);
						const container = document.getElementById('schedules-content');
						if (container) {
							container.innerHTML = '';
							const errorText = document.createElement('p');
							errorText.className = 'text-[11px] text-gray-400';
							errorText.textContent = 'Erreur de chargement';
							container.appendChild(errorText);
						}
					}
				}
			};
			
			// Charger les horaires immédiatement
			loadSchedules();
			
			// Actualiser selon l'intervalle configuré
			currentRefreshInterval = setInterval(loadSchedules, REFRESH_INTERVAL_MS);
			
			// Arrêter l'actualisation quand l'info-bulle est fermée
			google.maps.event.addListener(infoWindow, 'closeclick', () => {
				if (currentRefreshInterval) {
					clearInterval(currentRefreshInterval);
					currentRefreshInterval = null;
				}
				currentInfoWindow = null;
			});
		});

		return marker;
	}

	function createPolylinesFromGeometry(geometry, color, name, weight, bounds, properties) {
		const polylines = [];
		
		if (!geometry || !geometry.coordinates) return polylines;

		// Parser les coordonnées selon le type de géométrie
		if (geometry.type === 'LineString') {
			const path = geometry.coordinates.map(coord => {
				const latLng = new google.maps.LatLng(coord[1], coord[0]);
				bounds.extend(latLng);
				return latLng;
			});
			polylines.push(createPolyline(path, color, name, weight, properties));
		} else if (geometry.type === 'MultiLineString') {
			geometry.coordinates.forEach(lineString => {
				const path = lineString.map(coord => {
					const latLng = new google.maps.LatLng(coord[1], coord[0]);
					bounds.extend(latLng);
					return latLng;
				});
				polylines.push(createPolyline(path, color, name, weight, properties));
			});
		}
		
		return polylines;
	}

	function createPolyline(path, color, name, weight, properties) {
		// Créer une polyline avec geodesic: false pour afficher exactement les coordonnées brutes
		const polyline = new google.maps.Polyline({
			path: path,
			geodesic: false,
			strokeColor: color,
			strokeOpacity: 0.75,
			strokeWeight: weight,
			map: map,
			clickable: true
		});

		// Ajouter info-bulle au clic
		polyline.addListener('click', (event) => {
			// Fermer l'infoWindow précédente si elle existe
			if (currentInfoWindow) {
				currentInfoWindow.close();
			}
			
			// Arrêter l'actualisation précédente si elle existe
			if (currentRefreshInterval) {
				clearInterval(currentRefreshInterval);
				currentRefreshInterval = null;
			}
			
			const routeType = getRouteTypeName(properties.route_type);
			
			// Créer le conteneur avec Tailwind CSS
			const contentDiv = document.createElement('div');
			contentDiv.className = 'p-2.5 min-w-[200px]';
			
			const title = document.createElement('h3');
			title.className = 'm-0 mb-2 text-base font-semibold';
			title.textContent = name;
			contentDiv.appendChild(title);
			
			if (routeType) {
				const typeP = document.createElement('p');
				typeP.className = 'my-1 text-[13px] text-gray-600';
				typeP.textContent = `Type: ${routeType}`;
				contentDiv.appendChild(typeP);
			}
			
			if (properties.route_id) {
				const idP = document.createElement('p');
				idP.className = 'my-1 text-xs text-gray-400';
				idP.textContent = `ID: ${properties.route_id}`;
				contentDiv.appendChild(idP);
			}
			
			if (properties.operatorname) {
				const operatorP = document.createElement('p');
				operatorP.className = 'my-1 text-xs text-gray-400';
				operatorP.textContent = `Opérateur: ${properties.operatorname}`;
				contentDiv.appendChild(operatorP);
			}
			
			const infoWindow = new google.maps.InfoWindow({
				content: contentDiv,
				position: event.latLng
			});
			
			// Stocker l'infoWindow actuelle
			currentInfoWindow = infoWindow;
			infoWindow.open(map);
			
			// Nettoyer la référence quand fermée manuellement
			google.maps.event.addListener(infoWindow, 'closeclick', () => {
				currentInfoWindow = null;
			});
		});

		return polyline;
	}

	// Fonction pour obtenir le nom du type de transport
	function getRouteTypeName(routeType) {
		const types = {
			'0': 'Tramway',
			'1': 'Métro',
			'2': 'Train',
			'3': 'Bus',
			'4': 'Ferry',
			'5': 'Téléphérique',
			'6': 'Téléphérique suspendu',
			'7': 'Funiculaire',
			'Bus': 'Bus',
			'Métro': 'Métro',
			'Train': 'Train',
			'Tramway': 'Tramway',
			'RER': 'RER',
			'VAL': 'VAL'
		};
		return types[routeType] || routeType || 'Transport';
	}

	// Exposer la fonction updateStopsVisibility globalement pour le FilterPanel
	window.updateStopsVisibility = updateStopsVisibility;

	initMap();
</script>
